<html>
	<body>
		<link href="https://fonts.googleapis.com/css?family=Great+Vibes" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet"> 

		<style>
			* {
				position: relative;
				box-sizing: border-box;
				margin: 0px;
				padding: 0px;
			}
			html, body {
				width: 100%;
				height: 100%;
				color: #111;
				font-family: "Open Sans";
			}
			canvas {
				position: absolute;
				top: 0px;
				left: 0px;
			}
			h1 {
				font-family: "Great Vibes";
				font-size: 8em;
				color: #111;
			}
			h2 {
				font-size: 2em;
				margin-bottom: 1em;
			}
			p {
				font-size: 1em;
				margin-bottom: 1em;;
				line-height: 1.1em;
			}
			.section {
				padding: 60px;
			}
			.section.full {
				width: 100%;
				height: 100%;
			}
			.align {
				display: table;
			}
			.align.middle .content {
				vertical-align: middle;
			}
			.align.center {
				text-align: center;
			}
			.align .content {
				display: table-cell;
			}
			.container {
				max-width: 992px;
				margin: 0px auto;
			}
		</style>

		<div class="section full align middle center" id="splash-1"></div>

		<div class="section full align middle center" id="splash-2">
			<div class="content">
				<h1>Lorem ipsum</h1>
			</div>
		</div>

		<div class="section full align middle center" id="splash-3">
			<div class="content">
				<h1>Lorem ipsum</h1>
			</div>
		</div>

		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
		<script type="text/javascript" src="https://cdn.rawgit.com/humbletim/glm-js/31728cb4/build/glm-js.min.js"></script>
		<script type="text/javascript" src="glitch.js"></script>

		<script type="text/javascript">
	
			var ColorGrid = Glitch.Effect.extend({

				render: function(deltaTime, elapsedTime) {
					var rectSize = [
						this.canvas.width / this.options.size[0],
						this.canvas.height / this.options.size[1]
					];
					for (var x = 0; x < this.options.size[0]; ++x) {
						for (var y = 0; y < this.options.size[1]; ++y) {
							var point = [
								(x / this.options.size[0]) * 2 - 1,
								(y / this.options.size[1]) * 2 - 1
							];
							var color = [
								Math.sin(x * elapsedTime * .1),
								0,
								Math.cos(y * elapsedTime * .1)
							];
							var rgb = [
								255 - Math.floor(Math.abs(color[0] * 255)),
								255 - Math.floor(Math.abs(color[1] * 255)),
								255 - Math.floor(Math.abs(color[2] * 255))
							];
							this.context.fillStyle = "rgb("+rgb[0]+","+rgb[1]+","+rgb[2]+")";
							this.context.fillRect(
								rectSize[0] * x,
								rectSize[1] * y,
								rectSize[0] * (x + 1),
								rectSize[1] * (y + 1)
							);
						}
					}
				},

			});

			var DistancePoints = Glitch.Effect.extend({

				init: function() {
					this.vertices = [{
						position: [0, 0],
						velocity: [0, 0],
					}];
					for (var i = 1; i < this.options.numPoints - 1; ++i) {
						this.vertices[i] = {
							position: [
								Math.random() * this.canvas.width, 
								Math.random() * this.canvas.height
							],
							velocity: [
								Math.random() * 2 - 1,
								Math.random() * 2 - 1
							],
						};
					}
				},

				resize: function() {
					this.init();
				},

				mouseMove: function(cursor) {
					this.vertices[0].position = cursor;
				},

				render: function(deltaTime, elapsedTime) {
					this.context.fillStyle = "#ffffff";
					this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
					this.vertices.forEach(function(v0) {
						v0.velocity[0] *= (v0.position[0] > 0 && v0.position[0] < this.canvas.width) ? +1 : -1;
						v0.velocity[1] *= (v0.position[1] > 0 && v0.position[1] < this.canvas.height) ? +1 : -1;
						v0.position[0] += v0.velocity[0];
						v0.position[1] += v0.velocity[1];
						this.vertices.forEach(function(v1) {
							if (v0 === v1) {
								return false;
							}
							var delta = [
								v1.position[0] - v0.position[0],
								v1.position[1] - v0.position[1]
							];
							var distance = Math.sqrt(delta[0] * delta[0] + delta[1] * delta[1]);
							if (distance < this.options.maxDistance) {
								var opacity = 1 - (distance / this.options.maxDistance);
								var point = [
									(v0.position[0] / this.canvas.width) * 2 - 1,
									(v0.position[1] / this.canvas.height) * 2 - 1
								];
								var color = [
									opacity * point[0], 
									opacity *1, 
									opacity * point[1]
								];
								var rgb = [
									255 - Math.floor(Math.abs(color[0] * 255)),
									255 - Math.floor(Math.abs(color[1] * 255)),
									255 - Math.floor(Math.abs(color[2] * 255))
								];
								this.context.beginPath();
								this.context.moveTo(v0.position[0], v0.position[1]);
								this.context.lineTo(v1.position[0], v1.position[1]);
								this.context.closePath();
								this.context.strokeStyle = "rgb("+rgb[0]+","+rgb[1]+","+rgb[2]+")";
								this.context.stroke();
							}
						}, this);
					}, this);
				},

			});

			var GlitchText = Glitch.Effect.extend({

				render: function(deltaTime, elapsedTime) {

				},

			});

			new GlitchText({
				element: document.querySelector("#splash-1"),
				frameRate: 30,
				text: "Lorem ipsum",
			}).play();

			new ColorGrid({
				element: document.querySelector("#splash-2"),
				frameRate: 30,
				size: [8, 4],
			}).play();

			new DistancePoints({
				element: document.querySelector("#splash-3"),
				frameRate: 30,
				numPoints: 100,
				maxDistance: 200,
			}).play();

		</script>
	</body>
</html>

